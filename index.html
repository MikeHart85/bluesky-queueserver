

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>bluesky-queueserver Documentation &mdash; bluesky-queueserver 0.post15+gf9def9a documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/copybutton.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script src="_static/clipboard.min.js"></script>
        <script src="_static/copybutton.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Installation" href="installation.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="#" class="icon icon-home" alt="Documentation Home"> bluesky-queueserver
          

          
          </a>

          
            
            
              <div class="version">
                0.post15+gf9def9a
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="release-history.html">Release History</a></li>
<li class="toctree-l1"><a class="reference internal" href="min_versions.html">Minimum Version of Python and NumPy</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="#">bluesky-queueserver</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="#" class="icon icon-home"></a> &raquo;</li>
        
      <li>bluesky-queueserver Documentation</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/index.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="bluesky-queueserver-documentation">
<h1>bluesky-queueserver Documentation<a class="headerlink" href="#bluesky-queueserver-documentation" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="release-history.html">Release History</a></li>
<li class="toctree-l1"><a class="reference internal" href="min_versions.html">Minimum Version of Python and NumPy</a></li>
</ul>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This is currently under rapid development, the API may change at
any time.</p>
</div>
<div class="section" id="remote-and-multi-tenant-data-acquisition">
<h2>Remote and multi-tenant data acquisition<a class="headerlink" href="#remote-and-multi-tenant-data-acquisition" title="Permalink to this headline">¶</a></h2>
<p>In the traditional modes of experimental data collection the user
physically comes to the beamline.  The user has sole control of the
beamline during their beamtime (enforced by their physical presence at
the beamline!) which greatly reduces or makes moot many locking,
coordination, and security issues.  The physical presences at a
beamline work station also causes a blurring of several distinct tasks
that are being done simultaneously.  The urgent move to more remote
experimental data collection means we need to pull apart these tasks
and systematically address the permission issue.</p>
<p>One possible solution is to use some sort of remote desktop
application (VNC, NoMachine, …) or SSH access to the beamline machines.
While this may be sufficient for simple beamline operations, there are
performance concerns if widely used, it would require additional
infrastructure to make sure that multiple groups do not try to use the
beamline at the same time, and it gives remote users completely
unrestricted access to the beamline machines.</p>
<div class="section" id="components-of-remote-acquisition">
<h3>Components of Remote Acquisition<a class="headerlink" href="#components-of-remote-acquisition" title="Permalink to this headline">¶</a></h3>
<p>There are three distinct tasks involved in data acquisition</p>
<ol class="arabic simple">
<li><p>monitoring the beamline status (at least 0.5Hz update rate)</p></li>
<li><p>invoking the acquisition to collect the data</p></li>
<li><p>reviewing / processing / interacting with the just collected data</p></li>
</ol>
<p>that each have different requirements for interactivity / multi-tenant
/ authentication / latency and need to be addressed independently as
part of remote data acquisition.</p>
<div class="section" id="beamline-status">
<h4>Beamline status<a class="headerlink" href="#beamline-status" title="Permalink to this headline">¶</a></h4>
<p>During data collection users need to have access to at some high-level indications
of what the beamline is doing:</p>
<ul class="simple">
<li><p>is the RE running or idle?</p></li>
<li><p>is the shutter open?</p></li>
<li><p>is the ring up?</p></li>
<li><p>where are some key motors?</p></li>
</ul>
<p>which is best handled by something that will re-publish from EPICS to something
that can be exposed to the outside world.  There are a variety of ways this can be
done, including full web-based OPIs, industry standard logging tools, or simple
webpages.</p>
<p>If this also provides a high-level of engineering control to change individual PVs
is out of scope for this discussion.</p>
</div>
<div class="section" id="invoke-acquisition">
<h4>Invoke Acquisition<a class="headerlink" href="#invoke-acquisition" title="Permalink to this headline">¶</a></h4>
<p>This is running the beamline in an orchestrated way to acquire the
data that the user wants.  In the bluesky context this mean passing a
plan to the <cite>~bluesky.run_engine.RunEngine</cite>.  Doing this robustly for
(multiple) remote user is the primary goal of this package, see below
for more details.</p>
</div>
<div class="section" id="review-data">
<h4>Review Data<a class="headerlink" href="#review-data" title="Permalink to this headline">¶</a></h4>
<p>The users need some way to _promptly_ review the data that they have
collected, possibly running some preliminary data reduction.</p>
</div>
</div>
<div class="section" id="proposed-implementation">
<h3>Proposed implementation<a class="headerlink" href="#proposed-implementation" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id1">
<h4>Beamline status<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>This is best handled by something that will re-publish from EPICS to
something that can be exposed to the outside world.  There are a
variety of ways this can be done, including full web-based OPIs,
industry standard logging tools, or simple webpages.</p>
<p>If this also provides a high-level of engineering control to change
individual PVs is out of scope for this discussion.</p>
</div>
<div class="section" id="id2">
<h4>Invoke Acquisition<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>There are several scales of granularity that you can think about data acquisition:</p>
<ol class="arabic simple" start="0">
<li><p>physical access (you need to go in with a wrench and move things by hand)</p></li>
<li><p>direct access to the control system (i.e. reading / writing single PVs)</p></li>
<li><p>device level (i.e. ophyd objects, tango devices)</p></li>
<li><p>procedure level (i.e. bluesky plans, recursively procedures of procedures…)</p></li>
</ol>
<p>At each scale we depend on the lower level.</p>
<p>In line with standard security practice we want to provide users with
the minimum level of access that will let them achieve what they need
to.  To that end we are going to focus on providing remote access at
the procedure leve (4), i.e. the level of bluesky plans.</p>
<p>Because bluesky has the concept of specifying what you want to do
(calling the plan and passing it ophyd objects to get a generator)
from executing the plan (passing the generator to a RunEnigine) it is
natural to use the procedural level as the abstraction level to expose
for remote operations.  We will split the implementation into (at
least) 2 processes, one which handles the business logic / user
interaction / sessions and one which handles actually running the
plan.  By separating these two concerns we can develop them in
parallel and allow for a diversity of front ends that are used to
drive the acquisition.</p>
<p>It is in principle possible to build a full set of proxy devices and
procedures (as is done in Taurus), however this brings with it
significantly higher complexity of the communication between the
client and the server and gives (remote) user more privileges than
they strictly need.</p>
</div>
<div class="section" id="id3">
<h4>Review Data<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>The proposed method for accessing “prompt” data is an externally accessible
jupyterhub instance.  We can also use the same processing nodes to manage data
export to a format of the user’s choice.</p>
</div>
</div>
</div>
<div class="section" id="bluesky-queueserver-design">
<span id="design"></span><h2>bluesky-queueserver design<a class="headerlink" href="#bluesky-queueserver-design" title="Permalink to this headline">¶</a></h2>
<p>In the standard mode of operation the <code class="docutils literal notranslate"><span class="pre">RunEngine</span></code>, the ophyd
objects, and the connections to EPICS all live in the same process
that user runs on the beamline machine.  This assumes exclusive control of the
beamline, which when run _from_ the beamline is easy to guarantee.</p>
<p>To enable remote operation we propose a server which owns the
RunEngine instance and is the single (authenticated) entry point for
all users to the beamline.  This gives us:</p>
<ul class="simple">
<li><p>the ability to enforce exclusive control of the beamline</p></li>
<li><p>expose the ability to run scans without giving the users full access
to the beamline</p></li>
<li><p>the ability to provide per-user profiles of what devices and plans
the user has access to</p></li>
</ul>
<div class="section" id="high-level-design">
<h3>High-level design<a class="headerlink" href="#high-level-design" title="Permalink to this headline">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">RE</span> <span class="n">worker</span> <span class="o">&lt;----&gt;</span> <span class="n">api</span> <span class="n">server</span> <span class="o">&lt;--|</span><span class="n">edge</span><span class="o">-</span><span class="n">of</span><span class="o">-</span><span class="n">campus</span><span class="o">|--&gt;</span> <span class="n">client</span> <span class="p">(</span><span class="n">web</span> <span class="n">page</span><span class="p">)</span> <span class="o">&lt;-&gt;</span> <span class="n">user</span>
                    <span class="o">|</span>
                    <span class="o">|--</span> <span class="n">databases</span> <span class="p">(</span><span class="n">sample</span> <span class="o">+</span> <span class="n">admin</span><span class="p">)</span>
                    <span class="o">|--</span> <span class="n">queue</span>
</pre></div>
</div>
<div class="section" id="re-worker">
<h4>RE worker<a class="headerlink" href="#re-worker" title="Permalink to this headline">¶</a></h4>
<p>This is the process that holds the RE + ophyd objects + EPICs connections.
We want this to be independent from the web server so that:</p>
<ul class="simple">
<li><p>in case we drive the RE to an invalid state, we want to be able to
restart the RE without also restarting the web server.</p></li>
<li><p>makes it possible to re-launch the worker with the device / plan
profile of the current operator</p></li>
<li><p>makes it possible to launch the RE worker
process as the unix user that matches the current operator</p></li>
</ul>
<p>Currently the communication protocol between the worker and the server is
the plan running in the RE polls the server to get the next plan to be run
and the communicate via json.</p>
<p>This process has (almost) no persistent state (the scan_id still needs
to be externalized), everything it knows is either injected at start up time
or comes in with the “next plan” information from the web server.</p>
<p>This process is responsible for translating the serialized version (aka “names”)
of the plans / devices into live devices / plans and then running it.</p>
<div class="section" id="information-that-this-worker-needs-to-get">
<h5>Information that this worker needs to get<a class="headerlink" href="#information-that-this-worker-needs-to-get" title="Permalink to this headline">¶</a></h5>
<p>At start up:</p>
<ol class="arabic simple">
<li><p>what devices / plans are allowed</p></li>
<li><p>where to publish RE state to</p></li>
<li><p>where to publish data to</p></li>
<li><p>where to update the scan_id</p></li>
</ol>
<p>While running (which should be hand-shake interactions):</p>
<ol class="arabic simple">
<li><p>“the next plan”</p></li>
<li><p>interruptions / resumptions</p></li>
<li><p>changes to the loaded plans / devices</p></li>
</ol>
</div>
<div class="section" id="information-that-this-worker-needs-to-expose">
<h5>Information that this worker needs to expose<a class="headerlink" href="#information-that-this-worker-needs-to-expose" title="Permalink to this headline">¶</a></h5>
<p>Everything that needs to be exposed from this process should be
published via one of the channels that are passed in at startup.  We
do not want to burden this worker with significant
non-run-the-event-loop work both to avoid the risk of slowing down
data acquisition and because we expect these workers to be transient
and spawned by the web server.  We do not want to have to coordinate
communication with any other entities (they should instead subscribe to
the location where the information is published instead)</p>
</div>
</div>
<div class="section" id="web-server">
<h4>Web server<a class="headerlink" href="#web-server" title="Permalink to this headline">¶</a></h4>
<p>This is where the business logic of the remote operation lives.  This process
will be responsible for sorting out who the user is, what they are allowed to do,
managing the queue of things that need to be done, etc.</p>
<p>This process will take commands from the user like</p>
<ul class="simple">
<li><p>add this plan to the queue</p></li>
<li><p>re-order / remove things from the queue</p></li>
<li><p>update persistent meta-data (to go onto all plans)</p></li>
<li><p>interruptions to currently running scan</p></li>
<li><p>start / end / steal exclusive control</p></li>
<li><p>update the devices / plans available to the RE</p></li>
</ul>
<p>This process will need to manage the RE worker process so that it can be
(re) launched with the right profile / configuration loaded and it can be
interrupted.</p>
<p>This process will need to expose back to the user</p>
<ul class="simple">
<li><p>the current RE state (or where to get it)</p></li>
<li><p>recently taken data (or where to get it)</p></li>
<li><p>the current state of the queue</p></li>
<li><p>if the current session is “live” and has control of the beamline</p></li>
<li><p>the persistent meta-data</p></li>
</ul>
<p>This should be developed in line with standard REST API conventions to star with
and possibly a graphql API in the future.</p>
</div>
<div class="section" id="client">
<h4>Client<a class="headerlink" href="#client" title="Permalink to this headline">¶</a></h4>
<p>The clients can be anything that can post/get json to a https endpoint
and understands the protocols the sever exposes.  Possible clients are:</p>
<ul class="simple">
<li><p>httpi / curl</p></li>
<li><p>a Python cli tool built around a “restor”</p></li>
<li><p>a PyQt application tool built around a “restor”</p></li>
<li><p>a web application</p></li>
<li><p>an autonomous agent</p></li>
<li><p>Java base GUIs</p></li>
<li><p>…</p></li>
</ul>
<p>We expect there to be wide range of client that interact with server
of varying levels of complexity.  If we get the web server correct we
will be able to develop the clients independently.</p>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="installation.html" class="btn btn-neutral float-right" title="Installation" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2019, Brookhaven National Labratory

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>